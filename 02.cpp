/*过河卒
A点有一个过河卒 需要走到B点，它只能向下或者向右移动，
在棋盘中的任意一个点上又对方的马，记为C点
马所在的点和所有跳跃一步可达的点称为对方马的控制点。
请计算出小卒从A点能够顺利抵达B点的路径条数
输入：B点坐标(n,m)以及对方马C的坐标(x,y)(马的坐标一定在棋盘范围内，但可能落在边界上)
输出：小卒从A点到B点的路径条数
输入样例：6 6 3 2
输出样例：17
*/
#include<iostream>
using namespace std;
int main(){
	int a [30][30] = {0};//创建二维数组表示棋盘
	int n, m, x, y;//输入n m表示B点的行和列
	cin >> n >> m >> x >> y;
	
	for(int i=0;i<=n;i++)//从第0行开始遍历，到B点所在的行，即n行，因此包含n
		{
			for(int j=0;j<=m;j++)//遍历二维数组所有的列
			{
				a[i][j] = 1;
			}
		}
		a[x][y]=0;
			if(x+2<=n && y-1>=0){a[x+2][y-1]=0;}
			if(x+2<=n && y+1<=m){a[x+2][y+1]=0;}
			if(x+1<=n && y+2<=m){a[x+1][y+2]=0;}
			if(x-1>=0 && y+2<=m){a[x-1][y+2]=0;}
			if(x-2>=0 && y+1<=m){a[x-2][y+1]=0;}
			if(x-2>=0 && y-1>=0){a[x-2][y-1]=0;}
			if(x-1>=0 && y-2>=0){a[x-1][y-2]=0;}
			if(x+1<=n && y-2>=0){a[x+1][y-2]=0;}
	//遍历整个从A到B的二维数组
	for(int i=0;i<=n;i++)//从第0行开始遍历，到B点所在的行，即n行，因此包含n
	{
		for(int j=0;j<=m;j++)//遍历二维数组所有的列
		{
			if(i == 0 && j == 0){//如果B点的位置和A点重合，则不需要计算
				continue;
			}
			if(a[i][j]=0){
				continue;
			}
			if(i == 0){
				a[i][j] = a[i][j-1];
			}
			else if(j==0){
				a[i][j] = a[i-1][j];
			}
			else{
				a[i][j] = a[i-1][j] + a[i][j-1];
			}
		}
	}
	cout << a[n][m];
	
	return 0;
}
